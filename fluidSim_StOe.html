<!--
Copyright 2022 Matthias MÃ¼ller - Ten Minute Physics,
www.youtube.com/c/TenMinutePhysics
www.matthiasMueller.info/tenMinutePhysics

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<head>
    <title>Euler Fluid</title>
    <style>
        body {
            font-family: verdana, serif;
            font-size: 15px;
        }

        .button {
            background-color: #606060;
            border: none;
            color: white;
            padding: 10px 10px;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
        }

        /* .slider {         Never Used
             -webkit-appearance: none;
             width: 80px;
             height: 6px;
             border-radius: 5px;
             background: #d3d3d3;
             outline: none;
             opacity: 0.7;
             -webkit-transition: .2s;
             transition: opacity .2s;
         }

         */
    </style>
</head>

<body>

<button class="button" onclick="setupScene(1)">Wind Tunnel</button>
<button class="button" onclick="setupScene(3)">Hires Tunnel</button>
<button class="button" onclick="setupScene(0)">Tank</button>
<button class="button" onclick="setupScene(2)">Paint</button>
<input type="range" min="500" max="10000" value="1000" id="densitySlider">
<input type="range" min="0.00000000000001" max="0.0001" value="0.0000001" id="viscositySlider">
<input type="checkbox" id="streamButton" onclick="scene.showStreamlines = !scene.showStreamlines">Streamlines
<input type="checkbox" id="velocityButton" onclick="scene.showVelocities = !scene.showVelocities">Velocities
<input type="checkbox" name="field" id="pressureButton" onclick="scene.showPressure = !scene.showPressure;"> Pressure
<input type="checkbox" name="field" id="smokeButton" onclick="scene.showSmoke = !scene.showSmoke;" checked>Smoke
<input type="checkbox" id="overrelaxButton" onclick="scene.overRelaxation = scene.overRelaxation === 1.0 ? 1.9 : 1.0"
       checked>Overrelax

<br>
<canvas id="myCanvas" style="border:2px solid"></canvas>

<script>
    //TODO General
    //TODO Sliding obstacle over source "blocks" it, moving obstacle into source does not.
    //TODO Sliding obstacle over source "blocks" it, moving obstacle into source does not.
    //TODO Change all finite difference methods to central difference method
    //TODO Maybe make difference methods modular
    //TODO Add conditions for boundaries and obstacles to math-solver functions
    //TODO Decouple render speed from canvas size
    //TODO Separate Code into more manageable packages
    //TODO Add method to control and compare different numerical methods
    //TODO Let canvas size vary but sim size stays same, only visually stretched
    //TODO 3D with WebGl
    //TODO Add missing {} on if-statements for better readability
    //TODO Check if algorithms are focussed on rows first or collumns first
    //TODO decouple simulation speed from rendering speed
    //TODO Add dimensions to all physical units
    //TODO Make number of cells independent of sim cell size

    var canvas = document.getElementById("myCanvas");                         //Opens 2D Canvas API
    var canvas2DContext = canvas.getContext("2d");
    canvas.width = 600; //window.innerWidth - 20;          //TODO Make changeable. window.innerWidth is browser specific/current window
    //TODO Stays small when you start in a small window. Influences fluid speed
    canvas.height = 500; //window.innerHeight - 100;       //TODO Make changeable

    canvas.focus();                                 // Focused element receives keyboard and similar events by default

    var simHeight = 1.1;                        //TODO Make changeable
    var canvasScale = canvas.height / simHeight;		// Scale/extent of the canvas
    var simWidth = canvas.width / canvasScale;

    var xVel_FIELD = 0;		//"IDs" to differentiate the diffrent fields
    var yVel_FIELD = 1;
    var cellType_FIELD = 2;

    var cnt = 0;
    var densitySlider = document.getElementById("densitySlider");
    var densityValue = 1000;

    densitySlider.oninput = function () {
        densityValue = densitySlider.value;
        console.log(densityValue - densitySlider.value);
    }

    var viscositySlider = document.getElementById("viscositySlider");
    var viscosityValue = 0.0000001;

    viscositySlider.oninput = function () {
        viscosityValue = viscositySlider.value;
        console.log("Diff: viscVal - viscSliderVal. Should be 0, if not rip")
        console.log(viscosityValue - viscositySlider.value);
    }


    function simToCanvasX(x) {		//converts simulation coordinates into canvas coordinates
        return x * canvasScale;
    }

    function simToCanvasY(y) {		//converts simulation coordinates into canvas coordinates
        return canvas.height - y * canvasScale;
    }

    // ----------------- start of simulator ------------------------------
    //! Everytime we start at something like [i*n+j] where n=numY we start at the components of the array that are designated for the Y-Direcetion.
    //! This is necessary since we only use a "1D" Array and want to visualize something in 2D.
    //! it maps the two-dimensional indices i,j to the corresponding cell in the 1D-Array

    //! In each for-loop we first 'hold' the x-value. Therefore we do not iterate through the array row by row but collumn by collumn.
    //! The mapping from a 2D array to a 1D arra therefore uses the column-height numY instead of the row-width numX

    //! We treat the boundary rows and columns differently! Therefore all loops are ignoring the first and last row and column!
    //! I.e the top and bottom row and the leftmost and rightmost column!
    //! These are handled in the applyBoundaryCondition()-Method! This is to accuratly model fluid behaviour at the boundaries. I.e "no slip"-condition


    class FluidSim {
        //! Dividing by this.cellSize leads to NaN errors.
        constructor(density, numX, numY, simulationCellSize, viscosity) {
            this.density = density;
            this.viscosity = viscosity;
            this.numXCells = numX + 2;							//Number of Cells in x Direction; +2 for values at the edge
            this.numYCells = numY + 2;							//Number of Cells in y Direction; +2 for values at the edge
            this.numCells = this.numXCells * this.numYCells;			//Total number of cells. necessary to determine size of pressure, velocity etc. fields
            this.cellSize = simulationCellSize;										//Grid Spacing
            this.xVel = new Float64Array(this.numCells);		//Velocity Field in horizontal/X-Direction
            this.yVel = new Float64Array(this.numCells);		//Velocity Field in vertical/Y-Directions
            this.newXVel = new Float64Array(this.numCells);
            this.newYVel = new Float64Array(this.numCells);
            this.pressureField = new Float64Array(this.numCells);		//Pressure Field
            this.cellType = new Float64Array(this.numCells);		//Marker for all cells, s=0 for walls, s=1 for normal cells
            this.smokeField = new Float64Array(this.numCells);		//Smoke/Mist Field  1=white 0=black
            this.newSmokeField = new Float64Array(this.numCells);
            this.smokeField.fill(1.0)								//Start with "smoke value" of 1 everywhere
            // var num = numX * numY;							//Number of cells excluding Walls, currently not used
            this.xVel.fill(0.0);
            this.yVel.fill(0.0);
        }

//!-----------------------------------------New Math Functions--------------------------------
        computeLaplacian(field, i, j) { //Compute the lapalcian of a 2D VECTOR-FIELD! with second-order central difference method. Atm. vertical and horizontal component must be stored in separate 1D arrays
            //Laplacion of a function f(x,) with a step size/grid spacing of h. Note that a scalar field, like the pressure Field has no laplacian associated with it.
            //Lap_h_f(x,y)=( f(x-h, y) + f(x+h,y) + f(x,y-h) + f(x,y+h) - 4*f(x,y) )/(h*h)
            var n = this.numYCells;
            var laplacian = (field[(i - 1) * n + j] + field[(i + 1) * n + j] + field[i * n + j - 1] + field[i * n + j + 1] - 4 * field[i * n + j]) / (this.cellSize * this.cellSize); //Division leads to large numbers and overflow NaN
            return laplacian;
        }

        computeDivergence(horizontal, vertical, i, j) {
                var n = this.numYCells;
                var divergenceValue = (horizontal[(i + 1) * n + j] - horizontal[i * n + j] + vertical[i * n + j + 1] - vertical[i * n + j]); //Dividing by any number smaller than 1.0 leads to NaN, overflow.
                return divergenceValue;
            }



        computeViscousTerm(velocityField, viscosity, i, j) {
            let laplacian = this.computeLaplacian(velocityField, i, j);
            var viscousTerm = viscosity  * laplacian;
            return viscousTerm;
        }

        addViscousTerm(dt, viscosity) {
            var n = this.numYCells;
            for (var i = 1; i < this.numXCells - 1; i++) {
                for (var j = 1; j < n - 1; j++) {
                    var index = i * n + j;

                    if (this.cellType[i * n + j] != 0.0 && this.cellType[(i - 1) * n + j] != 0.0 && j < this.numYCells - 1) {              //check for obstacles and walls
                        var viscousTermX = this.computeViscousTerm(this.xVel, viscosity, i, j);
                        this.xVel[index] += dt * viscousTermX;
                    }

                    if (this.cellType[i * n + j] != 0.0 && this.cellType[(i - 1) * n + j] != 0.0 && j < this.numYCells - 1) {
                        var viscousTermY = this.computeViscousTerm(this.yVel, viscosity, i, j);
                        this.yVel[index] += dt * viscousTermY;
                    }
                }
            }
        }

        computePressureTerm(p, i, j, isHorizontal, dt) {
            //compute the influence of the pressure gradient on the velocity field by a forward finite difference method.
            // pressureDifference = p(x+h)-p(x) ) / h
            // pressureTermV(i,j) = pressureDifference(i,j) * dt / (density * cellSize);
            var n = this.numYCells;
            var index = i * n + j;

            if (isHorizontal = true) {
                //Compute horizontal pressure term
                var pressureDifferenceX = (this.pressureField[i * n + j] - this.pressureField[(i + 1) * n + j]) / this.cellSize;
                var pressureTermX = pressureDifferenceX * dt / (this.density * this.cellSize);
                //Note: [(i + 1) * n + j] is right of [i * n + j]
            } else {
                //Compute vertical pressure term
                var pressureDifferenceY = (this.pressureField[i * n + j] - this.pressureField[i * n + (j + 1)]) / this.cellSize;
                var pressureTermY = pressureDifferenceY * dt / (this.density * this.cellSize);
                //Note: [i * n + (j + 1)] is visually "below" [i * n + j]. Note that the y-direction of the grid points downwards
            }
            return (isHorizontal ? pressureTermX : pressureTermY);
        }

        //Solving Fields

        solvePressureField(pressureField, xVel, yVel, dt) {
            //TODO add static pressure
            var n = this.numYCells;
            var alpha = -dt / (this.density * this.cellSize * this.cellSize);  // rate of change of pressure over time due to the diffusion of the fluid
            var beta = 4.0;                                                  // Coefficient to increase more heavily weigh the adjacentPressureSum, for stability and convergence reasons.

            for (var i = 1; i < this.numXCells - 1; i++) {
                for (var j = 1; j < this.numYCells - 1; j++) {
                    var index = i * n + j;
                    var div = this.computeDivergence(xVel, yVel, i, j);                         //Calls the value of the divergence array at the index from the computeDivergence function

                    var cellType_x0 = this.cellType[(i - 1) * n + j];
                    var cellType_x1 = this.cellType[(i + 1) * n + j];
                    var cellType_y0 = this.cellType[i * n + j - 1];
                    var cellType_y1 = this.cellType[i * n + j + 1];
                    var numberFreeEdges = cellType_x0 + cellType_x1 + cellType_y0 + cellType_y1;		                            // sum up all values of s. This equals the Number of edges that are NOT walls.
                    if (numberFreeEdges == 0.0 || this.cellType[index] == 0.0)						// If the cell itself or all surrounding cells ar walls
                    {
                        continue;
                    }

                    var scaledDivergence = alpha * div; //Determines influence of the divergence on the pressure field (right hand sight of the poisson equation)
                    var adjacentPressureSum = pressureField[(i - 1) * n + j] + pressureField[(i + 1) * n + j] + pressureField[i * n + (j - 1)] + pressureField[i * n + (j + 1)]; //Sum up all surrounding pressure values

                    var newPressure = (scaledDivergence + beta * adjacentPressureSum) / (beta * numberFreeEdges);
                    pressureField[index] = newPressure;        //Set the newPressure at the index.
                }
            }
            console.log("Solved Pressure field")
        }

        addPressureTerm(dt) {
        var n = this.numYCells;
            for (let i = 1; i < this.numXCells; i++) {
                for (let j = 1; j < n - 1; j++) {
                    var index = i * n + j;
                    if (this.cellType[i * n + j] != 0.0 && this.cellType[(i - 1) * n + j] != 0.0 && j < this.numYCells - 1) {              //check for obstacles and walls
                        let pressureTermX = this.computePressureTerm(this.pressureField, true);
                        this.newXVel[index] += dt * pressureTermX;
                    }

                    if (this.cellType[i * n + j] != 0.0 && this.cellType[(i - 1) * n + j] != 0.0 && j < this.numYCells - 1) {
                        let pressureTermY = this.computePressureTerm(this.pressureField, false);
                        this.newYVel[index] += dt * pressureTermY;
                    }
                    this.xVel[index] += this.newXVel[index];
                    this.yVel[index] += this.newYVel[index];
                }
            }
        }

        newforceIncompressibility(numIters, dt, viscosity) { //! Leads to odd behaviour
            //Multiple iterations through all cells
            var n = this.numYCells;
            var densityValue = densitySlider.value;
            var currentPressure = densityValue * this.cellSize / dt;           //current static pressure
            var diffusionRate = viscosity * dt / (this.cellSize * this.cellSize);

            for (var iter = 0; iter < numIters; iter++) {    //Multiple iterations
                for (var i = 1; i < this.numX - 1; i++) {		// Go through all Cells
                    for (var j = 1; j < this.numY - 1; j++) {
                        var index = i * n + j;
                        //TODO is there a way to convert index to [(i - 1) * n + j] , [(i + 1) * n + j] and keep it readable? Research.
                        var div = this.computeDivergence(this.xVel, this.yVel, i, j);
                        if (this.cellType[index] === 0.0) {		// If there is a wall at s[i*n+j] go to the next cell
                            continue;
                        }
                        var cellType_x0 = this.cellType[(i - 1) * n + j];
                        var cellType_x1 = this.cellType[(i + 1) * n + j];
                        var cellType_y0 = this.cellType[i * n + j - 1];
                        var cellType_y1 = this.cellType[i * n + j + 1];
                        var numberFreeEdges = cellType_x0 + cellType_x1 + cellType_y0 + cellType_y1;		// sum up all values of s.  This s then equals the Number of edges that are NOT walls.
                        if (numberFreeEdges === 0.0) {				// If alle cells are walls, go to the next cell
                            continue;
                        }
                        var relativeDivergence = -div / numberFreeEdges;					// Equal part through each adjacent cells
                        relativeDivergence *= scene.overRelaxation;
                        this.pressureField[i * n + j] += currentPressure * relativeDivergence;

                        var laplacianX = this.computeLaplacian(this.xVel, i, j);
                        var laplacianY = this.computeLaplacian(this.yVel, i, j);

                        // Diffusion term added for viscosity
                        this.xVel[i * n + j] += diffusionRate * laplacianX - cellType_x0 * relativeDivergence;
                        this.xVel[(i + 1) * n + j] += diffusionRate * laplacianX + cellType_x1 * relativeDivergence;
                        this.yVel[i * n + j] += diffusionRate * laplacianY - cellType_y0 * relativeDivergence;
                        this.yVel[i * n + j + 1] += diffusionRate * laplacianY + cellType_y1 * relativeDivergence;
                    }
                }
            }
        }



//!--------------------------------------End Of New Math Functions----------------------------


        addGravity(dt, gravity)                              //adds gravity to v-component (vertical/Y) of all cells, updates vertical velocity
        {
            var n = this.numYCells;                              //! Start loops at 1, for fucks sake!
            for (var i = 1; i < this.numXCells; i++) {			//go through all X-Cells (rows)
                for (var j = 1; j < this.numYCells - 1; j++) {		//go through all Y-Cells (collumns) in that row
                    if (this.cellType[i * n + j] != 0.0 && this.cellType[i * n + j - 1] != 0.0)		//adds gravity if current and next cell are not walls (s!=0.0)
                        this.yVel[i * n + j] += gravity * dt;
                }
            }
        }


        //? Better Version than three for-loops possible?
        forceIncompressibility(numIters, dt) {
            //Solves poisson equation and secures incompressible behaviour
            //TODO: Move solving of poisson-equation to its own function. Multiple iterations through all cells
            var n = this.numYCells;
            var currentPressure = densityValue * this.cellSize / dt;			// current static pressure

            for (var iter = 0; iter < numIters; iter++) {    //Multiple iterations
                for (var i = 1; i < this.numXCells - 1; i++) {		// Go through all Cells
                    for (var j = 1; j < this.numYCells - 1; j++) {

                        if (this.cellType[i * n + j] == 0.0)			// If there is a wall at s[i*n+j] go to the next cell
                        {
                            continue;                            //! continue ends current iteration if reached and starts with the next
                        }                                           //? Doubling with condition if (numberFreeEdges == 0.0) ?


                        //var s = this.s[i * n + j];              //not used
                        var cellType_x0 = this.cellType[(i - 1) * n + j];
                        var cellType_x1 = this.cellType[(i + 1) * n + j];
                        var cellType_y0 = this.cellType[i * n + j - 1];
                        var cellType_y1 = this.cellType[i * n + j + 1];
                        var numberFreeEdges = cellType_x0 + cellType_x1 + cellType_y0 + cellType_y1;		// sum up all values of s.  This s then equals the Number of edges that are NOT walls.
                        if (numberFreeEdges == 0.0)						// If all surroounding cells are walls, go to the next cell. edge case for moving obstacles.
                        {
                            continue;
                        }

                        /*var divergence = this.xVel[(i + 1) * n + j] - this.xVel[i * n + j] +	//Compute current divergence. Total amount of Out-/Inflow of fluid
                            this.yVel[i * n + j + 1] - this.yVel[i * n + j];
                        */
                        var div = this.computeDivergence(this.xVel, this.yVel, i, j);

                        var relativeDivergence = -div / numberFreeEdges;					// Equal part through each adjacent cells
                        relativeDivergence *= scene.overRelaxation;                             // Scale up by overRelaxationFactor for faster convergence
                        this.pressureField[i * n + j] += currentPressure * relativeDivergence;  //! Ommits viscosity

                        this.xVel[i * n + j] -= cellType_x0 * relativeDivergence;			//Adjust all velocities so that an equal amount of fluid is pushed out of each cell.
                        this.xVel[(i + 1) * n + j] += cellType_x1 * relativeDivergence;	//Divergence then becomes Zero. Necessary for incomressible fluids
                        this.yVel[i * n + j] -= cellType_y0 * relativeDivergence;			// Edges with an associated cellType  of 0 are walls. therefore no fluid can flow through that edge
                        this.yVel[i * n + j + 1] += cellType_y1 * relativeDivergence;
                    }
                }
            }
        }

        applyBoundaryCondition() {				//applies the "no slip" boundary condition to the fluid
            var n = this.numYCells;
            for (var i = 0; i < this.numXCells; i++) {
                this.xVel[i * n + 0] = this.xVel[i * n + 1];                             //Copy the values of the second row to the top row
                this.xVel[i * n + this.numYCells - 1] = this.xVel[i * n + this.numYCells - 2];     //Copy the values of the second-to-last row to the bottom row
            }
            for (var j = 0; j < this.numYCells; j++) {
                this.yVel[0 * n + j] = this.yVel[1 * n + j];                             //Copy the values of the second column to the rightmost column
                this.yVel[(this.numXCells - 1) * n + j] = this.yVel[(this.numXCells - 2) * n + j]  //Copy the values of the second-to-last column to the leftmost column
            }
        }

        sampleField(x, y, fieldID) //Gets a sample value at location [x,y] of the given field, by bilinear interpolation. Interpreted as a weighted mean-value.
        {
            var n = this.numYCells;
            var h = this.cellSize;
            var h1 = 1.0 / h;   //Reciprocal of grid spacing h. Used to convert from physical- to grid-coordinates
            var h2 = 0.5 * h;

            x = Math.max(Math.min(x, this.numXCells * h), h);  //Get upper bound for x-coordinates: Math.minx(...), get lower bound for x-coordinates: Math.max(...), ensures x is within valid range.
            y = Math.max(Math.min(y, this.numYCells * h), h);  //Same in Y-Direction


            var dx = 0.0;           //Interpolation distances
            var dy = 0.0;           //Initialize here to make sure it is interpreted as a float to avoid eventual type coercion.

            var field;			//temporary variable the to be sampled field is assigned to

            switch (fieldID) {
                case xVel_FIELD:
                    field = this.xVel;
                    dy = h2;
                    break;
                case yVel_FIELD:
                    field = this.yVel;
                    dx = h2;
                    break;
                case cellType_FIELD:
                    field = this.smokeField;
                    dx = h2;
                    dy = h2;
                    break

            }

            var x0 = Math.min(Math.floor((x - dx) * h1), this.numXCells - 1); //Determine left neighbour of cell [x,y]. Flooring to get cell index.
            var x1 = Math.min(x0 + 1, this.numXCells - 1);                    //Determine right neighbour

            var y0 = Math.min(Math.floor((y - dy) * h1), this.numYCells - 1); //Determine lower neighbour
            var y1 = Math.min(y0 + 1, this.numYCells - 1);                    //Determine upper neighbour

            //Calculate bilinear-interpolation weights
            var tx = ((x - dx) - x0 * h) * h1;      //normalized distance lower left corner in x and why direction from point [x,y]
            var ty = ((y - dy) - y0 * h) * h1;

            var sx = 1.0 - tx;                      //normalized distance upper right corner in x and why direction from point [x,y]
            var sy = 1.0 - ty;

            var val;                                //weighted mean of all neighbouring cells of [x,y]
            val = sx * sy * field[x0 * n + y0] +
                tx * sy * field[x1 * n + y0] +
                tx * ty * field[x1 * n + y1] +
                sx * ty * field[x0 * n + y1];

            return val;
        }

        avgXVel(i, j) {			//Weighted-Average all u-components adjacent to the cell [i,j]
            var n = this.numYCells;
            var xVel = (this.xVel[i * n + j - 1] + this.xVel[i * n + j] +
                this.xVel[(i + 1) * n + j - 1] + this.xVel[(i + 1) * n + j]) * 0.25; //Why only right neighbour-cell weighted?
            return xVel;

        }

        avgYVel(i, j) {			//Weighted-Average all v-components adjacent to the cell [i,j]
            var n = this.numYCells;
            var yVel = (this.yVel[(i - 1) * n + j] + this.yVel[i * n + j] +
                this.yVel[(i - 1) * n + j + 1] + this.yVel[i * n + j + 1]) * 0.25;        //Why only upper neighbour cell weighted?
            return yVel;
        }

        advectVelocity(dt) {			//Moves velocity field by a timestep dt to simulate moving particles by Semi-Lagrangian Advection

            this.newXVel.set(this.xVel);
            this.newYVel.set(this.yVel);

            var n = this.numYCells;
            var h = this.cellSize;			//Grid Spacing
            var h2 = 0.5 * h;

            for (var i = 1; i < this.numXCells; i++) {		//Go through all cells
                for (var j = 1; j < this.numYCells; j++) {

                    cnt++; //? What for? Debugging?

                    // advect u component
                    if (this.cellType[i * n + j] != 0.0 && this.cellType[(i - 1) * n + j] != 0.0 && j < this.numYCells - 1) {              //check for obstacles and walls
                        let x = i * h;				                                                                    //Determine current  x-coordinate in terms of the grid
                        let y = j * h + h2;			                                                                    //?Same as x, add half a spaceing. Why an extra half step?
                        let u = this.xVel[i * n + j];	                                                                    //Get u-velocity at [i,j] / current position
                        let v = this.avgYVel(i, j);	                                                                    //Average v-velocity around [i,j] / current position
                        //var v = this.sampleField(x,y, V_FIELD); Option: sample instead of average
                        x = x - dt * u;				                                                                    //Determine previous position of the velocity currently stored in [i,j] /current position
                        y = y - dt * v;
                        u = this.sampleField(x, y, xVel_FIELD);		                                                    //Sample field at the previous position
                        this.newXVel[i * n + j] = u;					                                                    //Set new value of the u-field at the current position [i,j] to the value it had in
                    }                                                                                                   //the cell where that velocity it "came from". Store this in a separate field.
                                                                                                                        // I.e: calculate new velocity fieldHow

                    // same as above for v-component
                    if (this.cellType[i * n + j] != 0.0 && this.cellType[i * n + j - 1] != 0.0 && i < this.numXCells - 1) {
                        let x = i * h + h2;
                        let y = j * h;
                        var v = this.yVel[i * n + j];
                        let u = this.avgXVel(i, j);
                        // var u = this.sampleField(x,y, U_FIELD); Option: sample instead of average, worse performance?
                        x = x - dt * u;
                        y = y - dt * v;
                        v = this.sampleField(x, y, yVel_FIELD);
                        this.newYVel[i * n + j] = v;
                    }
                }
            }

            this.xVel.set(this.newXVel);      //Update the old velocity fields.
            this.yVel.set(this.newYVel);
        }

        advectSmoke(dt) { //Same logic as in advectVel

            this.newSmokeField.set(this.smokeField);

            var n = this.numYCells;
            var h = this.cellSize;
            var h2 = 0.5 * h;

            for (var i = 1; i < this.numXCells - 1; i++) //Go through all cells
            {
                for (var j = 1; j < this.numYCells - 1; j++) {

                    if (this.cellType[i * n + j] != 0.0)  //if the cell is not a wall
                    {
                        var u = (this.xVel[i * n + j] + this.xVel[(i + 1) * n + j]) * 0.5;        //TODO Why half thee value of the cell the cell to the right?
                        var v = (this.yVel[i * n + j] + this.yVel[i * n + j + 1]) * 0.5;
                        var x = i * h + h2 - dt * u;                                        //Get indices of previous cell location
                        var y = j * h + h2 - dt * v;

                        this.newSmokeField[i * n + j] = this.sampleField(x, y, cellType_FIELD);             //Advect
                    }
                }
            }
            this.smokeField.set(this.newSmokeField);
        }

        // ----------------- end of simulator ------------------------------


        performSimulationStep(dt, gravity, numIters, viscosity) {

            this.addGravity(dt, gravity);
            this.addViscousTerm(dt, viscosity);
            this.solvePressureField(this.pressureField, this.xVel, this.yVel, dt);
            //this.addPressureTerm(dt);
            this.pressureField.fill(0.0);				//TODO: Make optional to show why its necessary.Clear pressurefield.
            this.forceIncompressibility(numIters, dt);
            //this.newforceIncompressibility(numIters, dt, viscosity);


            this.applyBoundaryCondition();
            this.advectVelocity(dt);
            this.advectSmoke(dt);
            this.newXVel.fill(0.0);
            this.newYVel.fill(0.0);
            console.log("Max X-Vel:");
            console.log(Math.max(...this.xVel));
            console.log("Max Y-Vel:");
            console.log(Math.max(...this.yVel));
            console.log("CellSize");
            console.log(this.cellSize);

        }
    }

    var scene =			                            //TODO Make this into diffrent functions/options, first 1 example then in database
        {
            gravity: -9.81,			                //TODO Make Changeable and part of FluidSim
            dt: 1.0 / 120.0,		                //TODO Make Changeable and port of FluidSim
            numIters: 100,
            frameNr: 0,
            overRelaxation: 1.9,		            //TODO Make Changeable and part of FluidSim
            obstacleX: 0.0,                         //initial Obstacle Postion
            obstacleY: 0.0,
            obstacleRadius: 0.15,			        //TODO Add diffrent obstacles
            paused: false,				            //TODO Add Pause Button
            sceneNr: 0,
            showObstacle: false,		            //TODO Add Show/Hide Button
            showStreamlines: false,
            showVelocities: false,
            showPressure: false,
            showSmoke: true,
            fluidSim: null

        };

    function setupScene(sceneNr = 0)		//Always start with sceneNr = 0 aka Default-Start
    {
        scene.sceneNr = sceneNr;
        scene.obstacleRadius = 0.15;	//TODO Make Changeable
        scene.overRelaxation = 1.9;		//TODO Make changeable

        // scene.dt = 1.0 / 60.0;			//TODO Make changeable
        //scene.numIters = 40;			//TODO Make changeable

        var res = 100;					//Resolution


        //Establish simulation space
        var domainHeight = 1.0;										    //TODO Make changeable. Simulation height in simulation space units. Independent of physical units
        var domainWidth = domainHeight / simHeight * simWidth;          //Simulation width in simulation space units. Independent of physical units
        var setupCellSize = 0.01; //domainHeight / res;                                     //Grid spacing

        var numX = Math.floor(domainWidth / setupCellSize);						    //TODO Make changeable
        var numY = Math.floor(domainHeight / setupCellSize);					    //TODO Make changeable

        var density = densityValue;										//TODO Make changeable
        var viscosity = viscosityValue;
        console.log("NumX");
        console.log(numX);
        console.log("NumY");
        console.log(numY);


        fluidSimSetup = scene.fluidSim = new FluidSim(density, numX, numY, setupCellSize, viscosity);		    //Scene starts without a fluid, give it one
        var n = fluidSimSetup.numYCells;

        //TODO Decouple from Hard Code, add more scenes. Scenes stored in Database
        //Go through all cells
        if (sceneNr == 0) {   		// tank

            for (var i = 0; i < fluidSimSetup.numXCells; i++) {
                for (var j = 0; j < fluidSimSetup.numYCells; j++) {
                    var cellType = 1.0;
                    if (i == 0 || i == fluidSimSetup.numXCells - 1 || j == 0)	        //Mark bottom and edges as solid
                    {
                        cellType = 0.0;
                    }
                    fluidSimSetup.cellType[i * n + j] = cellType                    //Mark everything else as fluid
                }
            }

            scene.gravity = -9.81; //TODO make part of simulator and changeable
            scene.showPressure = true;
            scene.showSmoke = false;
            scene.showStreamlines = false;
            scene.showVelocities = false;
        } else if (sceneNr == 1 || sceneNr == 3) // vortex shedding
        {

            var inVel = 2.0;									//TODO make changeable, initial Velocity
            for (var i = 0; i < fluidSimSetup.numXCells; i++)                    //Go through all cells
            {
                for (var j = 0; j < fluidSimSetup.numYCells; j++) {
                    var cellType = 1.0;
                    if (i == 0 || j == 0 || j == fluidSimSetup.numYCells - 1)	//Mark edges and bottom as solid
                    {
                        cellType = 0.0;	// solid
                    }
                    fluidSimSetup.cellType[i * n + j] = cellType							//Mark everything as fluid
                    if (i == 1) {
                        fluidSimSetup.xVel[i * n + j] = inVel;     //Set velocity in the first column to 'inVel'
                    }
                }
            }

            var pipeH = 0.1 * fluidSimSetup.numYCells;							//TODO Make changeable. Diameter of the wind-pipe
            var minJ = Math.floor(0.5 * fluidSimSetup.numYCells - 0.5 * pipeH);  //Starting height of smoke tunnel. Changes position
            var maxJ = Math.floor(0.5 * fluidSimSetup.numYCells + 0.5 * pipeH);  //End height. Make narrower/wider

            for (var j = minJ; j < maxJ; j++)			//Makes smoke in the middle of the lefthand wall
            {                                           //TODO Add second loop, so that it is not only on the wall
                fluidSimSetup.smokeField[j] = 0.0;
            }

            setObstacle(0.4, 0.5, true)                 //Sets initial obstacle position and visible

            scene.gravity = 0.0;
            scene.showPressure = false;
            scene.showSmoke = true;
            scene.showStreamlines = false;
            scene.showVelocities = false;

            if (sceneNr == 3) {
                scene.dt = 1.0 / 120.0;
                scene.numIters = 100;
                scene.showPressure = true;
            }
//Setup Scene 2, paint simulation
        } else if (sceneNr == 2) {

            scene.gravity = 0.0;         //TODO Make changeable
            scene.overRelaxation = 1.0; //TODO make changeable
            scene.showPressure = false;
            scene.showSmoke = true;
            scene.showStreamlines = false;
            scene.showVelocities = false;
            scene.obstacleRadius = 0.1;
        }

        document.getElementById("streamButton").checked = scene.showStreamlines;
        document.getElementById("velocityButton").checked = scene.showVelocities;
        document.getElementById("pressureButton").checked = scene.showPressure;
        document.getElementById("smokeButton").checked = scene.showSmoke;
        document.getElementById("overrelaxButton").checked = scene.overRelaxation > 1.0;

    }


    // draw -------------------------------------------------------
    //! Reminder "c" ist the canvas

    function setColor(r, g, b) {
        canvas2DContext.fillStyle = `rgb(
                        ${Math.floor(255 * r)},
                        ${Math.floor(255 * g)},
                        ${Math.floor(255 * b)})`
        canvas2DContext.strokeStyle = `rgb(
                        ${Math.floor(255 * r)},
                        ${Math.floor(255 * g)},
                        ${Math.floor(255 * b)})`
    }

    function getSciColor(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001);     //Make sure 'val' is within range of 'minVal' and 'maxVal'. '- 0.0001' makes sure 'num' cant become '4', since we start the cases at '0'
        var diffrenceMinMax = maxVal - minVal;
        val = diffrenceMinMax == 0.0 ? 0.5 : (val - minVal) / diffrenceMinMax;     //If the difference is zero, set 'val = 0.5' (middle), otherwise normalize 'val' (Is now between 0 and 1)
                                                                                   //normalizes 'val'. Can be interpreted as its relative position between 'minVal' and 'maxVal' in '%'
        var m = 0.25;
        var num = Math.floor(val / m);                              //NOTE: Math.floor() returns the largest integer less than or equal to a given number.
                                                                    // If 'val' is between [0, <0.25] it gets rounded to 0. [0.25, <0.5] to 1; [0.5, <0.75] to 2; [0.75, <1] to 3
        var saturation = (val - num * m) / m;                       //between zero and 1
        var r, g, b;                                                //red, green, blue

        switch (num) {
            case 0: //Blues
                r = 0.0;
                g = saturation;
                b = 1.0;
                break;
            case 1: //Cyans
                r = 0.0;
                g = 1.0;
                b = 1.0 - saturation;
                break;
            case 2: //Greens
                r = saturation;
                g = 1.0;
                b = 0.0;
                break;
            case 3: //Yellows
                r = 1.0;
                g = 1.0 - saturation;
                b = 0.0;
                break;
        }

        return [255 * r, 255 * g, 255 * b, 255]                     //RGB value with an alpha value of 255 (last entry in array) / fully opaque
    }

    //Draws the results from the fluid simulation to the canvas
    function draw() {                                               //TODO Break down into smaler functions?
        canvas2DContext.clearRect(0, 0, canvas.width, canvas.height);             //Start with a blank canvas

        canvas2DContext.fillStyle = "#FF0000";                                    //Fill red
        fluidSimDraw = scene.fluidSim;                                            //Take the fluid from the scene
        n = fluidSimDraw.numYCells;                                                 //Grid Height
        var cellScale = 1.1;                                        //TODO Make adjustable Scaling factor
        var h = fluidSimDraw.cellSize;                                                //Grid Spacing

        minP = fluidSimDraw.pressureField[0];                                              //set 'minP' to pressure value of the first cell. To have a starting value to compare
        maxP = fluidSimDraw.pressureField[0];                                              //set 'maxP' to pressure value of the first cell.

        for (var i = 0; i < fluidSimDraw.numCells; i++) {                      //Go through each cell. Compare and update 'minP' and 'maxP'
            minP = Math.min(minP, fluidSimDraw.pressureField[i]);
            maxP = Math.max(maxP, fluidSimDraw.pressureField[i]);
        }

        canvasImageData = canvas2DContext.getImageData(0, 0, canvas.width, canvas.height)
        var rgb_colorArray = [255, 255, 255, 255]                            //color array far later reference of values

        //Go through all cells
        for (var i = 0; i < fluidSimDraw.numXCells; i++) {
            for (var j = 0; j < fluidSimDraw.numYCells; j++) {

                if (scene.showPressure) {    //If tickbox 'show Pressure' is selected.

                    var pressure = fluidSimDraw.pressureField[i * n + j];         //Get pressure Value
                    var saturation = fluidSimDraw.smokeField[i * n + j];         //Get value of smokeField, can be interpreted as saturation
                    rgb_colorArray = this.getSciColor(pressure, minP, maxP);
                    if (scene.showSmoke)                    //? Maybe as ternary operation instead of two 'if-statements'?
                    {
                        //adjust colours with saturation at the current point in the field
                        rgb_colorArray[0] = Math.max(0.0, rgb_colorArray[0] - 255 * saturation);
                        rgb_colorArray[1] = Math.max(0.0, rgb_colorArray[1] - 255 * saturation);
                        rgb_colorArray[2] = Math.max(0.0, rgb_colorArray[2] - 255 * saturation);
                    }
                } else if (scene.showSmoke) {
                    var smokeOpacity = fluidSimDraw.smokeField[i * n + j];     //adjust colours with saturation at the current point in the field
                    rgb_colorArray[0] = 255 * smokeOpacity;
                    rgb_colorArray[1] = 255 * smokeOpacity;
                    rgb_colorArray[2] = 255 * smokeOpacity;
                    if (scene.sceneNr == 2) {
                        rgb_colorArray = this.getSciColor(smokeOpacity, 0.0, 1.0);
                    }

                }
                //Colour the borders and bostacles black
                else if (fluidSimDraw.cellType[i * n + j] == 0.0) {
                    rgb_colorArray[0] = 0;
                    rgb_colorArray[1] = 0;
                    rgb_colorArray[2] = 0;
                }

                var x = Math.floor(simToCanvasX(i * h));                      //convert simulation coords to canvas cords
                var y = Math.floor(simToCanvasY((j + 1) * h));
                var cx = Math.floor(canvasScale * cellScale * h) + 1;    //Size of the canvas square in x direction. cx = canvas-Y
                var cy = Math.floor(canvasScale * cellScale * h) + 1;    //same for y
                //TODO better performance with just cy = cx?
                //cellScale and cScale (canvas scale) just as arbitrary scaling factors

                r = rgb_colorArray[0];
                g = rgb_colorArray[1];
                b = rgb_colorArray[2];

                for (var yi = y; yi < y + cy; yi++) { //go through all y-values
                    var p = 4 * (yi * canvas.width + x)  // p = starting index of the current pixel. Multiply by for since every pixel has 4 values. R,G,B and Alpha

                    for (var xi = 0; xi < cx; xi++) {   //go through all x-values
                        canvasImageData.data[p++] = r;               //Increment p by one after each. Start at p(red). Then add +1
                        canvasImageData.data[p++] = g;               //Steps to the green value of the current pixel, add +1 to get to blue, and one more to get to alpha
                        canvasImageData.data[p++] = b;
                        canvasImageData.data[p++] = 255;
                    }
                }
            }
        }

        canvas2DContext.putImageData(canvasImageData, 0, 0); //Put all the data(pixel values) of the  object id onto the canvas. starting at point [0, 0]

        if (scene.showVelocities) { //Shows current velocities and their direction
            //! Extremly laggy!
            //TODO dont show every velocity, similar to streamlines
            canvas2DContext.strokeStyle = "#000000";
            scale = 0.02;

            for (var i = 0; i < fluidSimDraw.numXCells; i++) {
                for (var j = 0; j < fluidSimDraw.numYCells; j++) {

                    var u = fluidSimDraw.xVel[i * n + j];
                    var v = fluidSimDraw.yVel[i * n + j];

                    canvas2DContext.beginPath();

                    x0 = simToCanvasX(i * h);
                    x1 = simToCanvasX(i * h + u * scale);
                    y = simToCanvasY((j + 0.5) * h);

                    canvas2DContext.moveTo(x0, y);
                    canvas2DContext.lineTo(x1, y);
                    canvas2DContext.stroke();

                    x = simToCanvasX((i + 0.5) * h);
                    y0 = simToCanvasY(j * h);
                    y1 = simToCanvasY(j * h + v * scale)

                    canvas2DContext.beginPath();
                    canvas2DContext.moveTo(x, y0);
                    canvas2DContext.lineTo(x, y1);
                    canvas2DContext.stroke();

                }
            }
        }

        if (scene.showStreamlines) {

            var segLen = fluidSimDraw.cellSize * 0.2;  //Segment length? Not used
            var numSegs = 5;         //Iteration length for drawing streamline. The biger the longer a streamline.
            //Lower means more individual streamlines.
            canvas2DContext.strokeStyle = "#000000";      //Streamline color

            for (var i = 1; i < fluidSimDraw.numXCells - 1; i += 5)         //Start a streamline at every fifth cell
            {                                               //TODO Make step-size changeable / controll streamline density
                for (var j = 1; j < fluidSimDraw.numYCells - 1; j += 5) {

                    var x = (i + 0.5) * fluidSimDraw.cellSize;
                    var y = (j + 0.5) * fluidSimDraw.cellSize;

                    canvas2DContext.beginPath();                          //Clear list of sub-paths and start a new one
                    canvas2DContext.moveTo(simToCanvasX(x), simToCanvasY(y));                 //at position [x,y]

                    for (var n = 0; n < numSegs; n++) {
                        var u = fluidSimDraw.sampleField(x, y, xVel_FIELD);
                        var v = fluidSimDraw.sampleField(x, y, yVel_FIELD);
                        var l = Math.sqrt(u * u + v * v);
                        // x += u/l * segLen;
                        // y += v/l * segLen;
                        x += u * 0.01;                      //Move coordinate along with a time step of 0.01
                        y += v * 0.01;                      //TODO Make consistent with general timestep
                        if (x > fluidSimDraw.numXCells * fluidSimDraw.cellSize) {             //Stop if out of bounce
                            break;
                        }
                        canvas2DContext.lineTo(simToCanvasX(x), simToCanvasY(y));             //take the new position as endpoint of the line
                    }
                    canvas2DContext.stroke();                             //Actually draw the line on the canvas
                }
            }
        }

        if (scene.showObstacle) {               //Adjusts obstacle size depending on the grid spacing
            radius = scene.obstacleRadius + fluidSimDraw.cellSize;     //Grid spacing dependent on browser size
            if (scene.showPressure) {
                canvas2DContext.fillStyle = "#000000";        //Set fill colour to black if 'show Pressure' is selected
            } else {
                canvas2DContext.fillStyle = "#DDDDDD";        //Else make light gray
            }
            //Draws two half circles and combines them to a circle
            canvas2DContext.beginPath();
            canvas2DContext.arc(simToCanvasX(scene.obstacleX), simToCanvasY(scene.obstacleY), canvasScale * radius, 0.0, 2.0 * Math.PI);
            canvas2DContext.closePath();
            canvas2DContext.fill();


            canvas2DContext.lineWidth = 3.0; //!Unnecessary
            canvas2DContext.strokeStyle = "#000000";          //! Make a black edge. cool
            canvas2DContext.beginPath();
            canvas2DContext.arc(simToCanvasX(scene.obstacleX), simToCanvasY(scene.obstacleY), canvasScale * radius, 0.0, 2.0 * Math.PI);
            canvas2DContext.closePath();
            canvas2DContext.stroke();
            canvas2DContext.lineWidth = 1.0;  //!Unnecessary
        }


        //Display current min and max Pressure at the top left
        //TODO Unecessary in this way. always show pressure instead
        if (scene.showPressure) {
            var displayPressureString = "pressure: " + minP.toFixed(0) + " - " + maxP.toFixed(0) + " N/m";
            canvas2DContext.fillStyle = "#000000";
            canvas2DContext.font = "16px Arial";
            canvas2DContext.fillText(displayPressureString, 10, 35);
        }
    }

    //-----------------------end of draw function ----------------------------------------
    function setObstacle(x, y, reset) {
        //x and y = center position of the obstacle

        //! What causes a reset?
        var obstacleVelX = 0.0;                       //initial Object velocities
        var obstacleVelY = 0.0;

        if (!reset) {                       //Calculate object velocity
            obstacleVelX = (x - scene.obstacleX) / scene.dt;
            obstacleVelY = (y - scene.obstacleY) / scene.dt;
        }

        scene.obstacleX = x;                //Set new location
        scene.obstacleY = y;
        var r = scene.obstacleRadius;
        var fluidSimSetObstacle = scene.fluidSim;
        var n = fluidSimSetObstacle.numYCells;
        var cd = Math.sqrt(2) * fluidSimSetObstacle.cellSize;  //!Never used. Length of the diagonal of a cell

        for (var i = 1; i < fluidSimSetObstacle.numXCells - 2; i++)        //Go through all cells
        {
            for (var j = 1; j < fluidSimSetObstacle.numYCells - 2; j++) {

                fluidSimSetObstacle.cellType[i * n + j] = 1.0;               //Mark every cell as fluid
                dx = (i + 0.5) * fluidSimSetObstacle.cellSize - x;
                dy = (j + 0.5) * fluidSimSetObstacle.cellSize - y;
                //! Currently only works for circles
                if (dx * dx + dy * dy < r * r) {        // if the cell is within the outline of the circle
                    fluidSimSetObstacle.cellType[i * n + j] = 0.0;               //mark it as solid
                    if (scene.sceneNr == 2) {
                        fluidSimSetObstacle.smokeField[i * n + j] = 0.5 + 0.5 * Math.sin(0.1 * scene.frameNr)  //Vary smoke opacity if the current cell is solid.
                    }                                                               //This visualizes the dispersing of the the smoke, when it hits an object
                    else {
                        fluidSimSetObstacle.smokeField[i * n + j] = 1.0;
                    }
                    //Set the value of the velocity field to the speed of the obstacle, when it is within the outline of the obstacle
                    fluidSimSetObstacle.xVel[i * n + j] = obstacleVelX;
                    fluidSimSetObstacle.xVel[i * n + j] = obstacleVelX;
                    fluidSimSetObstacle.xVel[(i + 1) * n + j] = obstacleVelX;
                    fluidSimSetObstacle.yVel[i * n + j] = obstacleVelY;
                    fluidSimSetObstacle.yVel[i * n + j + 1] = obstacleVelY;
                }
            }
        }

        scene.showObstacle = true;
    }

    // interaction -------------------------------------------------------

    var mouseDown = false;

    function startDrag(x, y) {
        let bounds = canvas.getBoundingClientRect(); //Gets size and position of the canvas in current viewport

        let mx = x - bounds.left - canvas.clientLeft;  //convert cursor position from viewport to canvas coordinates
        let my = y - bounds.top - canvas.clientTop;
        mouseDown = true;

        x = mx / canvasScale;                                //
        y = (canvas.height - my) / canvasScale;

        setObstacle(x, y, true);                        //set obstacle to updated position
    }

    function drag(x, y) {
        if (mouseDown) {
            let bounds = canvas.getBoundingClientRect();
            let mx = x - bounds.left - canvas.clientLeft;
            let my = y - bounds.top - canvas.clientTop;
            x = mx / canvasScale;
            y = (canvas.height - my) / canvasScale;
            setObstacle(x, y, false);
        }
    }

    function endDrag() {
        mouseDown = false;
    }

    canvas.addEventListener('mousedown', event => {     //If mouse button ist pressed, call startDrag
        startDrag(event.x, event.y);                    //passes the coordinates where the event occured
    });

    canvas.addEventListener('mouseup', event => {       //If mouse button is lifted, call endDrag
        endDrag();
    });

    canvas.addEventListener('mousemove', event => {     //If cursor is moved, call drag
        drag(event.x, event.y);
    });

    canvas.addEventListener('touchstart', event => {
        startDrag(event.touches[0].clientX, event.touches[0].clientY)
    });

    canvas.addEventListener('touchend', event => {
        endDrag()
    });

    canvas.addEventListener('touchmove', event => {
        event.preventDefault();
        event.stopImmediatePropagation();
        drag(event.touches[0].clientX, event.touches[0].clientY)
    }, {passive: false});


    document.addEventListener('keydown', event => {     //TODo make more visable, mabye add buttons
        switch (event.key) {
            case 'p':
                scene.paused = !scene.paused;
                break;
            case 'm':
                scene.paused = false;
                updateSimulation();
                scene.paused = true;
                break;     //Frame by frame
        }
    });

    function toggleStart()          //TODO add start button, function is never used
    {
        var button = document.getElementById('startButton');
        if (scene.paused)
            button.innerHTML = "Stop";
        else
            button.innerHTML = "Start";
        scene.paused = !scene.paused;
    }

    // main -------------------------------------------------------

    function updateSimulation() {
        if (!scene.paused)
            scene.fluidSim.performSimulationStep(scene.dt, scene.gravity, scene.numIters, scene.fluidSim.viscosity)
        scene.frameNr++;
    }

    function runSimulationLoop() {     //infinite loop
        updateSimulation();
        draw();
        //setTimeout(draw(), 5000);
        requestAnimationFrame(runSimulationLoop); //calls runSimulationLoop again, which calls requestAnimationFrame again
    }

    setupScene(1);
    runSimulationLoop();

</script>
</body>
</html>