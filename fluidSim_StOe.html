<!--
Copyright 2022 Matthias MÃ¼ller - Ten Minute Physics,
www.youtube.com/c/TenMinutePhysics
www.matthiasMueller.info/tenMinutePhysics

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<head>
  <title>Euler Fluid</title>
  <style>
    body {
      font-family: verdana, serif;
      font-size: 15px;
    }

    .button {
      background-color: #606060;
      border: none;
      color: white;
      padding: 10px 10px;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
    }

    /* .slider {         Never Used
         -webkit-appearance: none;
         width: 80px;
         height: 6px;
         border-radius: 5px;
         background: #d3d3d3;
         outline: none;
         opacity: 0.7;
         -webkit-transition: .2s;
         transition: opacity .2s;
     }

     */
  </style>
</head>

<body>

<button class="button" onclick="setupScene(1)">Wind Tunnel</button>
<button class="button" onclick="setupScene(3)">Hires Tunnel</button>
<button class="button" onclick="setupScene(0)">Tank</button>
<button class="button" onclick="setupScene(2)">Paint</button>
<input type="range" min="500" max="10000" value="1000" id="densitySlider">
<input type="checkbox" id="streamButton" onclick="scene.showStreamlines = !scene.showStreamlines">Streamlines
<input type="checkbox" id="velocityButton" onclick="scene.showVelocities = !scene.showVelocities">Velocities
<input type="checkbox" name="field" id="pressureButton" onclick="scene.showPressure = !scene.showPressure;"> Pressure
<input type="checkbox" name="field" id="smokeButton" onclick="scene.showSmoke = !scene.showSmoke;" checked>Smoke
<input type="checkbox" id="overrelaxButton" onclick="scene.overRelaxation = scene.overRelaxation === 1.0 ? 1.9 : 1.0"
       checked>Overrelax

<br>
<canvas id="myCanvas" style="border:2px solid"></canvas>

<script>
  //TODO General
  //TODO Sliding obstacle over source "blocks" it, moving obstacle into source does not.
  //Git comment test


  var canvas = document.getElementById("myCanvas");
  var c = canvas.getContext("2d");
  canvas.width = window.innerWidth - 20;          //TODO Make changeable. window.innerWidth is browser specific/current window
                                                  //TODO Stays small when you start in a small window. Influences fluid speed
  canvas.height = window.innerHeight - 100;       //TODO Make changeable

  canvas.focus();                                 // Focused element receives keyboard and similar events by default

  var simHeight = 1.1;                        //TODO Make changeable
  var cScale = canvas.height / simHeight;		// Scale/extent of the canvas
  var simWidth = canvas.width / cScale;

  var U_FIELD = 0;		//"IDs" to differentiate the diffrent fields
  var V_FIELD = 1;
  var S_FIELD = 2;

  var cnt = 0;
  var densitySlider = document.getElementById("densitySlider");
  var densityValue;

  densitySlider.oninput = function () {
    densityValue = densitySlider.value;
    console.log(densityValue - densitySlider.value);

  }


  function cX(x) {		//converts simulation coordinates into canvas coordinates
    return x * cScale;
  }

  function cY(y) {		//converts simulation coordinates into canvas coordinates
    return canvas.height - y * cScale;
  }

  // ----------------- start of simulator ------------------------------
  //! Everytime we start at something like [i*n+j] where n=numY we start at the components of the array that are designated for the Y-Direcetion.
  //! This is necessary since we only use a "1D" Array and want to visualize something in 2D.
  //! it maps the two-dimensional indices i,j to the corresponding cell in the 1D-Array

  //! In each for-loop we first 'hold' the x-value. Therefore we do not iterate through the array row by row but collumn by collumn.
  //! The mapping from a 2D array to a 1D arra therefore uses the column-height numY instead of the row-width numX

  //! We treat the boundary rows and columns differently! Therefore all loops are ignoring the first and last row and column!
  //! I.e the top and bottom row and the leftmost and rightmost column!
  //! These are handled in the applyBoundaryCondition()-Method! This is to accuratly model fluid behaviour at the boundaries. I.e "no slip"-condition
  //TODO Expand to 3D. For-loops to slow?
  //TODO Add missing {} on if-statements for better readability
  //TODO Check if algorithms are focussed on rows first or collumns first

  class fluidSim {   //TODO Change name to FluidSim
    constructor(density, numX, numY, simulationCellSize)                 // TODO numX & numY simulation width or fluid width? can fluid expand? Research
    {
      this.density = density;
      this.numX = numX + 2;							//Number of Cells in x Direction; +2 for values at the edge
      this.numY = numY + 2;							//Number of Cells in y Direction; +2 for values at the edge
      this.numCells = this.numX * this.numY;			//Total number of cells. necessary to determine size of pressure, velocity etc. fields
      this.h = simulationCellSize;										//Grid Spacing
      this.u = new Float32Array(this.numCells);		//Velocity Field in horizontal/X-Direction
      this.v = new Float32Array(this.numCells);		//Velocity Field in vertical/Y-Direction
      this.newU = new Float32Array(this.numCells);
      this.newV = new Float32Array(this.numCells);
      this.pressureField = new Float32Array(this.numCells);		//Pressure Field
      this.s = new Float32Array(this.numCells);		//Marker for all cells, s=0 for walls, s=1 for normal cells
      this.m = new Float32Array(this.numCells);		//Smoke/Mist Field
      this.newM = new Float32Array(this.numCells);
      this.m.fill(1.0)								//Start with "smoke value" of 1 everywhere
      // var num = numX * numY;							//Number of cells excluding Walls, currently not used
    }

    addGravity(dt, gravity)                              //adds gravity to v-component (vertical/Y) of all cells, updates vertical velocity
    {
      var n = this.numY;                              //! Start loops at 1, for fucks sake!
      for (var i = 1; i < this.numX; i++) {			//go through all X-Cells (rows)
        for (var j = 1; j < this.numY - 1; j++) {		//go through all Y-Cells (collumns) in that row
          if (this.s[i * n + j] != 0.0 && this.s[i * n + j - 1] != 0.0)		//adds gravity if current and next cell are not walls (s!=0.0)
            this.v[i * n + j] += gravity * dt;                              //Why Type coercion?!
        }
      }
    }


    //? Better Version than three for-loops possible?
    forceIncompressibility(numIters, dt) {				//Solves poisson equation and secures incompressible behaviour
      //TODO: Move solving of poisson-equation to its own function. Multiple iterations through all cells
      var n = this.numY;
      var currentPressure = densityValue * this.h / dt;			// current static pressure

      for (var iter = 0; iter < numIters; iter++) {    //Multiple iterations
        for (var i = 1; i < this.numX - 1; i++) {		// Go through all Cells
          for (var j = 1; j < this.numY - 1; j++) {

            if (this.s[i * n + j] == 0.0)			// If there is a wall at s[i*n+j] go to the next cell
            {
              continue;                            //! continue ends current iteration if reached and starts with the next
            }                                           //? Doubling with condition if (numberFreeEdges == 0.0) ?


            //var s = this.s[i * n + j];              //not used
            var sx0 = this.s[(i - 1) * n + j];
            var sx1 = this.s[(i + 1) * n + j];
            var sy0 = this.s[i * n + j - 1];
            var sy1 = this.s[i * n + j + 1];
            var numberFreeEdges = sx0 + sx1 + sy0 + sy1;		// sum up all values of s.  This s then equals the Number of edges that are NOT walls.
            if (numberFreeEdges == 0.0)						// If all surroounding cells are walls, go to the next cell. edge case for moving obstacles.
            {
              continue;
            }

            var divergence = this.u[(i + 1) * n + j] - this.u[i * n + j] +	//Compute current divergence. Total amount of Out-/Inflow of fluid
                    this.v[i * n + j + 1] - this.v[i * n + j];

            var relativeDivergence = -divergence / numberFreeEdges;					// Equal part through each adjacent cells
            relativeDivergence *= scene.overRelaxation;                             // Scale up by overRelaxationFactor for faster convergence
            this.pressureField[i * n + j] += currentPressure * relativeDivergence;  //! Ommits viscosity

            this.u[i * n + j] -= sx0 * relativeDivergence;			//Adjust all velocities so that an equal amount of fluid is pushed out of each cell.
            this.u[(i + 1) * n + j] += sx1 * relativeDivergence;	//Divergence then becomes Zero. Necessary for incomressible fluids
            this.v[i * n + j] -= sy0 * relativeDivergence;			// Edges with an associated s value of 0 are walls. therefore no fluid can flow through that edge
            this.v[i * n + j + 1] += sy1 * relativeDivergence;
          }
        }
      }
    }

    applyBoundaryCondition() {				//applies the "no slip" boundary condition to the fluid
      var n = this.numY;
      for (var i = 0; i < this.numX; i++) {
        this.u[i * n + 0] = this.u[i * n + 1];                             //Copy the values of the second row to the top row
        this.u[i * n + this.numY - 1] = this.u[i * n + this.numY - 2];     //Copy the values of the second-to-last row to the bottom row
      }
      for (var j = 0; j < this.numY; j++) {
        this.v[0 * n + j] = this.v[1 * n + j];                             //Copy the values of the second column to the rightmost column
        this.v[(this.numX - 1) * n + j] = this.v[(this.numX - 2) * n + j]  //Copy the values of the second-to-last column to the leftmost column
      }
    }

    sampleField(x, y, field) //Gets a sample value at location [x,y] of the given field, by bilinear interpolation. Interpreted as a weighted mean-value.
    {
      var n = this.numY;
      var h = this.h;
      var h1 = 1.0 / h;   //Reciprocal of grid spacing h. Used to convert from physical- to grid-coordinates
      var h2 = 0.5 * h;

      x = Math.max(Math.min(x, this.numX * h), h);  //Get upper bound for x-coordinates: Math.minx(...), get lower bound for x-coordinates: Math.max(...), ensures x is within valid range.
      y = Math.max(Math.min(y, this.numY * h), h);  //Same in Y-Direction


      var dx = 0.0; //? Sample steps?
      var dy = 0.0;

      var f;			//temporary variable the to be sampled field is assigned to

      switch (field) {
        case U_FIELD:
          f = this.u;
          dy = h2;
          break;
        case V_FIELD:
          f = this.v;
          dx = h2;
          break;
        case S_FIELD:
          f = this.m;
          dx = h2;
          dy = h2;
          break

      }

      var x0 = Math.min(Math.floor((x - dx) * h1), this.numX - 1); //Determine left neighbour of cell [x,y]. Flooring to get cell index.
      var x1 = Math.min(x0 + 1, this.numX - 1);                    //Determine right neighbour

      var y0 = Math.min(Math.floor((y - dy) * h1), this.numY - 1); //Determine lower neighbour
      var y1 = Math.min(y0 + 1, this.numY - 1);                    //Determine upper neighbour

      //Calculate bilinear-interpolation weights
      var tx = ((x - dx) - x0 * h) * h1;      //normalized distance lower left corner in x and why direction from point [x,y]
      var ty = ((y - dy) - y0 * h) * h1;

      var sx = 1.0 - tx;                      //normalized distance upper right corner in x and why direction from point [x,y]
      var sy = 1.0 - ty;

      var val;                                //weighted mean of all neighbouring cells of [x,y]
      val = sx * sy * f[x0 * n + y0] +
              tx * sy * f[x1 * n + y0] +
              tx * ty * f[x1 * n + y1] +
              sx * ty * f[x0 * n + y1];

      return val;
    }

    avgU(i, j) {			//Weighted-Average all u-components adjacent to the cell [i,j]
      var n = this.numY;
      var u = (this.u[i * n + j - 1] + this.u[i * n + j] +
              this.u[(i + 1) * n + j - 1] + this.u[(i + 1) * n + j]) * 0.25; //Why only right neighbour-cell weighted?
      return u;

    }

    avgV(i, j) {			//Weighted-Average all v-components adjacent to the cell [i,j]
      var n = this.numY;
      var v = (this.v[(i - 1) * n + j] + this.v[i * n + j] +
              this.v[(i - 1) * n + j + 1] + this.v[i * n + j + 1]) * 0.25;        //Why only upper neighbour cell weighted?
      return v;
    }

    advectVelocity(dt) {			//Moves velocity field by a timestep dt to simulate moving particles by Semi-Lagrangian Advection

      this.newU.set(this.u);
      this.newV.set(this.v);

      var n = this.numY;
      var h = this.h;			//Grid Spacing
      var h2 = 0.5 * h;

      for (var i = 1; i < this.numX; i++) {		//Go through all cells
        for (var j = 1; j < this.numY; j++) {

          cnt++; //? What for? Debugging?

          // advect u component
          if (this.s[i * n + j] != 0.0 && this.s[(i - 1) * n + j] != 0.0 && j < this.numY - 1) {              //check for obstacles and walls
            let x = i * h;				                                                                    //Determine current  x-coordinate in terms of the grid
            let y = j * h + h2;			                                                                    //?Same as x, add half a spaceing. Why an extra half step?
            let u = this.u[i * n + j];	                                                                    //Get u-velocity at [i,j] / current position
            let v = this.avgV(i, j);	                                                                    //Average v-velocity around [i,j] / current position
            //var v = this.sampleField(x,y, V_FIELD); Option: sample instead of average
            x = x - dt * u;				                                                                    //Determine previous position of the velocity currently stored in [i,j] /current position
            y = y - dt * v;
            u = this.sampleField(x, y, U_FIELD);		                                                    //Sample field at the previous position
            this.newU[i * n + j] = u;					                                                    //Set new value of the u-field at the current position [i,j] to the value it had in
          }                                                                                                   //the cell where that velocity it "came from". Store this in a separate field.
                                                                                                              // I.e: calculate new velocity fieldHow

          // same as above for v-component
          if (this.s[i * n + j] != 0.0 && this.s[i * n + j - 1] != 0.0 && i < this.numX - 1) {
            let x = i * h + h2;
            let y = j * h;
            var v = this.v[i * n + j];
            let u = this.avgU(i, j);
            // var u = this.sampleField(x,y, U_FIELD); Option: sample instead of average, worse performance?
            x = x - dt * u;
            y = y - dt * v;
            v = this.sampleField(x, y, V_FIELD);
            this.newV[i * n + j] = v;
          }
        }
      }

      this.u.set(this.newU);      //Update the old velocity fields.
      this.v.set(this.newV);
    }

    advectSmoke(dt) { //Same logic as in advectVel

      this.newM.set(this.m);

      var n = this.numY;
      var h = this.h;
      var h2 = 0.5 * h;

      for (var i = 1; i < this.numX - 1; i++) //Go through all cells
      {
        for (var j = 1; j < this.numY - 1; j++) {

          if (this.s[i * n + j] != 0.0)  //if the cell is not a wall
          {
            var u = (this.u[i * n + j] + this.u[(i + 1) * n + j]) * 0.5;        //TODO Why half thee value of the cell the cell to the right?
            var v = (this.v[i * n + j] + this.v[i * n + j + 1]) * 0.5;
            var x = i * h + h2 - dt * u;                                        //Get indices of previous cell location
            var y = j * h + h2 - dt * v;

            this.newM[i * n + j] = this.sampleField(x, y, S_FIELD);             //Advect
          }
        }
      }
      this.m.set(this.newM);
    }

    // ----------------- end of simulator ------------------------------


    performSimulationStep(dt, gravity, numIters) {

      this.addGravity(dt, gravity);

      this.pressureField.fill(0.0);				//? Starting with Zero pressure, make changeable
      this.forceIncompressibility(numIters, dt);

      this.applyBoundaryCondition();
      this.advectVelocity(dt);
      this.advectSmoke(dt);
    }
  }

  var scene =			                            //TODO Make this into diffrent functions/options, first 1 example then in database
          {
            gravity: -9.81,			                //TODO Make Changeable
            dt: 1.0 / 120.0,		                //TODO Make Changeable
            numIters: 100,
            frameNr: 0,
            overRelaxation: 1.9,		            //TODO Make Changeable
            obstacleX: 0.0,                         //Obstacle Postion
            obstacleY: 0.0,
            obstacleRadius: 0.15,			        //TODO Add diffrent obstacles
            paused: false,				            //TODO Add Pause Button
            sceneNr: 0,
            showObstacle: false,		            //TODO Add Show/Hide Button
            showStreamlines: false,
            showVelocities: false,
            showPressure: false,
            showSmoke: true,
            fluid: null
          };

  function setupScene(sceneNr = 0)		//Always start with sceneNr = 0 aka Default-Start
  {
    scene.sceneNr = sceneNr;
    scene.obstacleRadius = 0.15;	//TODO Make Changeable
    scene.overRelaxation = 1.9;		//TODO Make changeable

    scene.dt = 1.0 / 60.0;			//TODO Make changeable
    scene.numIters = 40;			//TODO Make changeable

    var res = 100;					//Resolution

    if (sceneNr == 0)
      res = 50;
    else if (sceneNr == 3)          //!Lags like hell
      res = 200;
    //Establish simulation space
    var domainHeight = 1.0;										    //TODO Make changeable. Simulation height in simulation space units. Independent of physical units
    var domainWidth = domainHeight / simHeight * simWidth;          //Simulation width in simulation space units. Independent of physical units
    var h = domainHeight / res;                                     //Grid spacing

    var numX = Math.floor(domainWidth / h);						    //TODO Make changeable
    var numY = Math.floor(domainHeight / h);					    //TODO Make changeable

    var density = densityValue;										//TODO Make changeable

    f = scene.fluid = new fluidSim(density, numX, numY, h);		    //Scene starts without a fluid, give it one

    var n = f.numY;

    //TODO Decouple from Hard Code, add more scenes. Scenes stored in Database
    //Go through all cells
    if (sceneNr == 0) {   		// tank

      for (var i = 0; i < f.numX; i++) {
        for (var j = 0; j < f.numY; j++)
        {
          var s = 1.0;
          if (i == 0 || i == f.numX - 1 || j == 0)	        //Mark bottom and edges as solid
          {
            s = 0.0;
          }
          f.s[i * n + j] = s                                  //Mark everything else as fluid
        }
      }

      scene.gravity = -9.81;
      scene.showPressure = true;
      scene.showSmoke = false;
      scene.showStreamlines = false;
      scene.showVelocities = false;
    }
    else if (sceneNr == 1 || sceneNr == 3) // vortex shedding
    {

      var inVel = 2.0;									//TODO initial Velocity, make changeable
      for (var i = 0; i < f.numX; i++)                    //Go through all cells
      {
        for (var j = 0; j < f.numY; j++) {
          var s = 1.0;
          if (i == 0 || j == 0 || j == f.numY - 1)	//Mark edges and bottom as solid
          {
            s = 0.0;	// solid
          }
          f.s[i * n + j] = s							//Mark everything as fluid
          if (i == 1)                                 //Set velocity in the first column to 'inVel'
          {
            f.u[i * n + j] = inVel;
          }
        }
      }

      var pipeH = 0.1 * f.numY;							//TODO Make changeable. Diameter of the wind-pipe
      var minJ = Math.floor(0.5 * f.numY - 0.5 * pipeH);  //Starting height of smoke tunnel. Changes position
      var maxJ = Math.floor(0.5 * f.numY + 0.5 * pipeH);  //End height. Make narrower/wider

      for (var j = minJ; j < maxJ; j++)			//Makes smoke in the middle of the lefthand wall
      {                                           //TODO Add second loop, so that it is not only on the wall
        f.m[j] = 0.0;
      }

      setObstacle(0.4, 0.5, true)                 //Sets initial obstacle position and visible

      scene.gravity = 0.0;				//todo Vortex shedding with gravity?
      scene.showPressure = false;
      scene.showSmoke = true;
      scene.showStreamlines = false;
      scene.showVelocities = false;

      if (sceneNr == 3) {
        scene.dt = 1.0 / 120.0;
        scene.numIters = 100;
        scene.showPressure = true;
      }

    } else if (sceneNr == 2) // paint
    {

      scene.gravity = 0.0;         //TODO Make changeable
      scene.overRelaxation = 1.0; //TODO make changeable
      scene.showPressure = false;
      scene.showSmoke = true;
      scene.showStreamlines = false;
      scene.showVelocities = false;
      scene.obstacleRadius = 0.1;
    }

    document.getElementById("streamButton").checked = scene.showStreamlines;
    document.getElementById("velocityButton").checked = scene.showVelocities;
    document.getElementById("pressureButton").checked = scene.showPressure;
    document.getElementById("smokeButton").checked = scene.showSmoke;
    document.getElementById("overrelaxButton").checked = scene.overRelaxation > 1.0;

  }


  // draw -------------------------------------------------------
  //! Reminder "c" ist the canvas

  function setColor(r, g, b) {
    c.fillStyle = `rgb(
                        ${Math.floor(255 * r)},
                        ${Math.floor(255 * g)},
                        ${Math.floor(255 * b)})`
    c.strokeStyle = `rgb(
                        ${Math.floor(255 * r)},
                        ${Math.floor(255 * g)},
                        ${Math.floor(255 * b)})`
  }

  function getSciColor(val, minVal, maxVal) {
    val = Math.min(Math.max(val, minVal), maxVal - 0.0001);     //Make sure 'val' is within range of 'minVal' and 'maxVal'. '- 0.0001' makes sure 'num' cant become '4', since we start the cases at '0'
    var diffrenceMinMax = maxVal - minVal;
    val = diffrenceMinMax == 0.0 ? 0.5 : (val - minVal) / diffrenceMinMax;     //If the difference is zero, set 'val = 0.5' (middle), otherwise normalize 'val' (Is now between 0 and 1)
                                                                               //normalizes 'val'. Can be interpreted as its relative position between 'minVal' and 'maxVal' in '%'
    var m = 0.25;
    var num = Math.floor(val / m);                              //NOTE: Math.floor() returns the largest integer less than or equal to a given number.
                                                                // If 'val' is between [0, <0.25] it gets rounded to 0. [0.25, <0.5] to 1; [0.5, <0.75] to 2; [0.75, <1] to 3
    var saturation = (val - num * m) / m;                       //between zero and 1
    var r, g, b;                                                //red, green, blue

    switch (num) {
      case 0:
        r = 0.0;
        g = saturation;
        b = 1.0;
        break;                 //Blues
      case 1:
        r = 0.0;
        g = 1.0;
        b = 1.0 - saturation;
        break;           //Cyans
      case 2:
        r = saturation;
        g = 1.0;
        b = 0.0;
        break;                 //Greens
      case 3:
        r = 1.0;
        g = 1.0 - saturation;
        b = 0.0;
        break;           //Yellows
    }

    return [255 * r, 255 * g, 255 * b, 255]                     //RGB value with an alpha value of 255 (last entry in array) / fully opaque
  }
  //Draws the results from the fluid simulation to the canvas
  function draw() {                                               //TODO Break down into smaler functions?
    c.clearRect(0, 0, canvas.width, canvas.height);             //Start with a blank canvas

    c.fillStyle = "#FF0000";                                    //Fill red
    f = scene.fluid;                                            //Take the fluid from the scene
    n = f.numY;                                                 //Grid Height
    var cellScale = 1.1;                                        //TODO Make adjustable Scaling factor
    var h = f.h;                                                //Grid Spacing

    minP = f.pressureField[0];                                              //set 'minP' to pressure value of the first cell. To have a starting value to compare
    maxP = f.pressureField[0];                                              //set 'maxP' to pressure value of the first cell.

    for (var i = 0; i < f.numCells; i++) {                      //Go through each cell. Compare and update 'minP' and 'maxP'
      minP = Math.min(minP, f.pressureField[i]);
      maxP = Math.max(maxP, f.pressureField[i]);
    }

    imageData = c.getImageData(0, 0, canvas.width, canvas.height)
    var rgb_colorArray = [255, 255, 255, 255]                            //color array far later reference of values

    //Go through all cells
    for (var i = 0; i < f.numX; i++) {
      for (var j = 0; j < f.numY; j++) {

        if (scene.showPressure) {    //If tickbox 'show Pressure' is selected.

          var p = f.pressureField[i * n + j];         //Go through pressure field
          var saturation = f.m[i * n + j];         //s = saturation. Go through smoke field
          rgb_colorArray = getSciColor(p, minP, maxP);     //! Currently only gets pressure from p.[0]
          if (scene.showSmoke)                    //? Maybe as ternary operation instead of two 'if-statements'?
          {
            //adjust colours with saturation at the current point in the field
            rgb_colorArray[0] = Math.max(0.0, rgb_colorArray[0] - 255 * saturation);
            rgb_colorArray[1] = Math.max(0.0, rgb_colorArray[1] - 255 * saturation);
            rgb_colorArray[2] = Math.max(0.0, rgb_colorArray[2] - 255 * saturation);
          }
        } else if (scene.showSmoke) {
          var s = f.m[i * n + j];     //adjust colours with saturation at the current point in the field
          rgb_colorArray[0] = 255 * s;
          rgb_colorArray[1] = 255 * s;
          rgb_colorArray[2] = 255 * s;
          if (scene.sceneNr == 2) {
            rgb_colorArray = getSciColor(s, 0.0, 1.0);
          }

        }
        //Colour the borders and bostacles black
        else if (f.s[i * n + j] == 0.0) {
          rgb_colorArray[0] = 0;
          rgb_colorArray[1] = 0;
          rgb_colorArray[2] = 0;
        }

        var x = Math.floor(cX(i * h));                      //convert simulation coords to canvas cords
        var y = Math.floor(cY((j + 1) * h));
        var cx = Math.floor(cScale * cellScale * h) + 1;    //Size of the canvas square in x direction. cx = canvas-Y
        var cy = Math.floor(cScale * cellScale * h) + 1;    //same for y
                                                            //TODO better performance with just cy = cx?
                                                            //cellScale and cScale (canvas scale) just as arbitrary scaling factors

        r = rgb_colorArray[0];
        g = rgb_colorArray[1];
        b = rgb_colorArray[2];

        for (var yi = y; yi < y + cy; yi++) { //go through all y-values
          var p = 4 * (yi * canvas.width + x)  // p = starting index of the current pixel. Multiply by for since every pixel has 4 values. R,G,B and Alpha

          for (var xi = 0; xi < cx; xi++) {   //go through all x-values
            imageData.data[p++] = r;               //Increment p by one after each. Start at p(red). Then add +1
            imageData.data[p++] = g;               //Steps to the green value of the current pixel, add +1 to get to blue, and one more to get to alpha
            imageData.data[p++] = b;
            imageData.data[p++] = 255;
          }
        }
      }
    }

    c.putImageData(imageData, 0, 0); //Put all the data(pixel values) of the  object id onto the canvas. starting at point [0, 0]

    if (scene.showVelocities) { //Shows current velocities and their direction
      //! Extremly laggy!
      //TODO dont show every velocity, similar to streamlines
      c.strokeStyle = "#000000";
      scale = 0.02;

      for (var i = 0; i < f.numX; i++) {
        for (var j = 0; j < f.numY; j++) {

          var u = f.u[i * n + j];
          var v = f.v[i * n + j];

          c.beginPath();

          x0 = cX(i * h);
          x1 = cX(i * h + u * scale);
          y = cY((j + 0.5) * h);

          c.moveTo(x0, y);
          c.lineTo(x1, y);
          c.stroke();

          x = cX((i + 0.5) * h);
          y0 = cY(j * h);
          y1 = cY(j * h + v * scale)

          c.beginPath();
          c.moveTo(x, y0);
          c.lineTo(x, y1);
          c.stroke();

        }
      }
    }

    if (scene.showStreamlines) {

      var segLen = f.h * 0.2;  //Segment length? Not used
      var numSegs = 5;         //Iteration length for drawing streamline. The biger the longer a streamline.
      //Lower means more individual streamlines.
      c.strokeStyle = "#000000";      //Streamline color

      for (var i = 1; i < f.numX - 1; i += 5)         //Start a streamline at every fifth cell
      {                                               //TODO Make step-size changeable / controll streamline density
        for (var j = 1; j < f.numY - 1; j += 5) {

          var x = (i + 0.5) * f.h;
          var y = (j + 0.5) * f.h;

          c.beginPath();                          //Clear list of sub-paths and start a new one
          c.moveTo(cX(x), cY(y));                 //at position [x,y]

          for (var n = 0; n < numSegs; n++) {
            var u = f.sampleField(x, y, U_FIELD);
            var v = f.sampleField(x, y, V_FIELD);
            var l = Math.sqrt(u * u + v * v);
            // x += u/l * segLen;
            // y += v/l * segLen;
            x += u * 0.01;                      //Move coordinate along with a time step of 0.01
            y += v * 0.01;                      //TODO Make consistent with general timestep
            if (x > f.numX * f.h) {             //Stop if out of bounce
              break;
            }
            c.lineTo(cX(x), cY(y));             //take the new position as endpoint of the line
          }
          c.stroke();                             //Actually draw the line on the canvas
        }
      }
    }

    if (scene.showObstacle) {               //Adjusts obstacle size depending on the grid spacing
      radius = scene.obstacleRadius + f.h;     //Grid spacing dependent on browser size
      if (scene.showPressure) {
        c.fillStyle = "#000000";        //Set fill colour to black if 'show Pressure' is selected
      }
      else {
        c.fillStyle = "#DDDDDD";        //Else make light gray
      }
      //Draws half a circle and fills it
      c.beginPath();
      c.arc(cX(scene.obstacleX), cY(scene.obstacleY), cScale * radius, 0.0, 2.0 * Math.PI);
      c.closePath();
      c.fill();

      //!Draws another half circle?!
      c.lineWidth = 3.0; //!Unnecessary
      c.strokeStyle = "#000000";          //! Make a black edge. cool
      c.beginPath();
      c.arc(cX(scene.obstacleX), cY(scene.obstacleY), cScale * radius, 0.0, 2.0 * Math.PI);
      c.closePath();
      c.stroke();
      c.lineWidth = 1.0;  //!Unnecessary
    }
    //? Two half circles better compute than one normal circle?

    //Display current min and max Pressure at the top left
    //TODO Unecessary in this way. always show pressure instead
    if (scene.showPressure) {
      var displayPressureString = "pressure: " + minP.toFixed(0) + " - " + maxP.toFixed(0) + " N/m";
      c.fillStyle = "#000000";
      c.font = "16px Arial";
      c.fillText(displayPressureString, 10, 35);
    }
  }

  //-----------------------end of draw function ----------------------------------------
  function setObstacle(x, y, reset) {     //x and y = center position of the obstacle
    //! What causes a reset?
    var vx = 0.0;                       //initial Object velocities?
    var vy = 0.0;

    if (!reset) {                       //Calculate object velocity
      vx = (x - scene.obstacleX) / scene.dt;
      vy = (y - scene.obstacleY) / scene.dt;
    }

    scene.obstacleX = x;                //Set new location
    scene.obstacleY = y;
    var r = scene.obstacleRadius;
    var f = scene.fluid;
    var n = f.numY;
    var cd = Math.sqrt(2) * f.h;  //!Never used. Length of the diagonal of a cell

    for (var i = 1; i < f.numX - 2; i++)        //Go through all cells
    {
      for (var j = 1; j < f.numY - 2; j++) {

        f.s[i * n + j] = 1.0;               //Mark every cell as fluid
        dx = (i + 0.5) * f.h - x;
        dy = (j + 0.5) * f.h - y;
        //! Currently only works for circles
        if (dx * dx + dy * dy < r * r) {        // if the cell is within the outline of the circle
          f.s[i * n + j] = 0.0;               //mark it as solid
          if (scene.sceneNr == 2) {
            f.m[i * n + j] = 0.5 + 0.5 * Math.sin(0.1 * scene.frameNr)  //Vary smoke opacity if the current cell is solid.
          }                                                               //This visualizes the dispersing of the the smoke, when it hits an object
          else {
            f.m[i * n + j] = 1.0;
          }
          //Set the value of the velocity field to the speed of the obstacle, when it is within the outline of the obstacle
          f.u[i * n + j] = vx;
          f.u[i * n + j] = vx;
          f.u[(i + 1) * n + j] = vx;
          f.v[i * n + j] = vy;
          f.v[i * n + j + 1] = vy;
        }
      }
    }

    scene.showObstacle = true;
  }

  // interaction -------------------------------------------------------

  var mouseDown = false;

  function startDrag(x, y) {
    let bounds = canvas.getBoundingClientRect(); //Gets size and position of the canvas in current viewport

    let mx = x - bounds.left - canvas.clientLeft;  //convert cursor position from viewport to canvas coordinates
    let my = y - bounds.top - canvas.clientTop;
    mouseDown = true;

    x = mx / cScale;                                //
    y = (canvas.height - my) / cScale;

    setObstacle(x, y, true);                        //set obstacle to updated position
  }

  function drag(x, y) {
    if (mouseDown) {
      let bounds = canvas.getBoundingClientRect();
      let mx = x - bounds.left - canvas.clientLeft;
      let my = y - bounds.top - canvas.clientTop;
      x = mx / cScale;
      y = (canvas.height - my) / cScale;
      setObstacle(x, y, false);
    }
  }

  function endDrag() {
    mouseDown = false;
  }

  canvas.addEventListener('mousedown', event => {     //If mouse button ist pressed, call startDrag
    startDrag(event.x, event.y);                    //passes the coordinates where the event occured
  });

  canvas.addEventListener('mouseup', event => {       //If mouse button is lifted, call endDrag
    endDrag();
  });

  canvas.addEventListener('mousemove', event => {     //If cursor is moved, call drag
    drag(event.x, event.y);
  });

  canvas.addEventListener('touchstart', event => {
    startDrag(event.touches[0].clientX, event.touches[0].clientY)
  });

  canvas.addEventListener('touchend', event => {
    endDrag()
  });

  canvas.addEventListener('touchmove', event => {
    event.preventDefault();
    event.stopImmediatePropagation();
    drag(event.touches[0].clientX, event.touches[0].clientY)
  }, {passive: false});


  document.addEventListener('keydown', event => {     //TODo make more visable, mabye add buttons
    switch (event.key) {
      case 'p':
        scene.paused = !scene.paused;
        break;
      case 'm':
        scene.paused = false;
        updateSimulation();
        scene.paused = true;
        break;     //Frame by frame
    }
  });

  function toggleStart()          //TODO add start button, function is never used
  {
    var button = document.getElementById('startButton');
    if (scene.paused)
      button.innerHTML = "Stop";
    else
      button.innerHTML = "Start";
    scene.paused = !scene.paused;
  }

  // main -------------------------------------------------------

  function updateSimulation() {
    if (!scene.paused)
      scene.fluid.performSimulationStep(scene.dt, scene.gravity, scene.numIters)
    scene.frameNr++;
  }

  function runSimulationLoop() {     //infinite loop
    updateSimulation();
    draw();
    requestAnimationFrame(runSimulationLoop); //calls runSimulationLoop again, which calls requestAnimationFrame again
  }

  setupScene(1);
  runSimulationLoop();

</script>
</body>
</html>